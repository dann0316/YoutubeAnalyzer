# FE: React + TypeScript + Vite / BE: Node.js + Express.js / DB: Firebase
# Youtube Analyzer

: Youtube 채널 및 영상 데이터를 분석하고, 성과도를 시각화하는 서비스

> 예상한 사용자 페르소나

- 유튜브 알고리즘에 관심 있는 사용자
    
    : 어떤 영상이 유튜브에서 잘 밀어주는지 궁금한 사용자
    
- 콘텐츠 방향을 고민 중인 초보 유튜버
    
    : 유튜브를 막 시작했지만 어떤 콘텐츠를 만들지 방향을 잡지 못한 사용자
    
- 영상별 성과를 수치와 시각화로 보고싶은 사용자
    
    : 조회수 외에도 다양한 지표로 영상의 경쟁력을 파악하고 싶은 사용자
    
- 디지털 마케터 / 인플루언서 마케터

- 배포 URL: (추가 예정)

- 기술 스택: React, TypeScript, Vite, Tailwind CSS, Chart.js, shadcn UI 라이브러리, Youtube Data API v3, Node.js, Express.js, Firebase(Fire Authentication, FireStore Database, Firebase Store), Puppeteer (웹 크롤링 기능 일부 포함 예정 -> 핫한 키워드), AWS EC2


# 아키텍쳐 및 폴더 구조:

> 프론트엔드와 백엔드 분리 구조(FE <-> BE API 통신)

> frontend: 사용자 UI/UX 담당 -> 데이터 fetch, 시각화, 페이지 라우팅

- 레이어드 아키텍쳐 (Layered Architecure)

: 역할별로 layer로 분리하여 각 layer의 관심사를 분리하여 유지보수성과 확장성을 높임

> backend: Youtube Data API v3 호출 및 인증, 데이터 가공, CORS 우회 처리, Firebase에 정보 저장 및 토큰 관리

> 데이터 흐름

Client (React)  →  Backend (Express API Server)  →  Youtube API  
         ↑                ↓  
    Chart.js 시각화   가공된 JSON 응답

> 폴더 구조

project-root/

├── frontend/                 # React + Vite 프론트엔드

│   ├── src/

│   │   ├── components/       # 공통 UI 컴포넌트 (Chart, VideoCard, LoadingUI 등)

│   │   ├── hooks/            # 데이터 fetch, 상태 관리 커스텀 훅

│   │   ├── pages/            # 라우트 페이지 (Home, VideoDetail 등)

│   │   ├── types/            # 타입 정의

│   │   ├── utils/            # 헬퍼 함수 (API 요청 등)

│   │   ├── route.tsx         # 라우트 구조 정의

│   │   └── main.tsx          # 앱 진입점

│   └── vite.config.ts        # Vite 설정

│

└── backend/                  # Node.js + Express 백엔드

    ├── src/

    │   ├── auth/             # 유저 정보 관련

    │   ├── types/            # 백엔드 서버 타입 관리

    │   ├── utils/            # Firebase 초기화 파일 및 open ai 초기화 파일

    ├── server.ts             # 서버 진입점 및 비즈니스 로직 (API 요청 및 데이터 가공)

    ├── tsconfig.json         # TypeScript 설정


# 설계 전략 설명:

> FE 로직과 뷰 분리

- 데이터 요청·가공·상태 전환은 hooks/와 services(api)/에서 처리, 화면은 components//pages/는 렌더링 + 이벤트 바인딩만 담당.

> 상태관리 전략: Zustand 중심 + 훅 래핑

- 전역 상태(Zustand): 사용자 토큰/세션, 선택한 영상 목록, 페이징 토큰(nextPageToken), 장기 유지 UI 상태(예: 가짜 프로그레스 %, 로딩 플래그).

- 지역 상태(React useState): 모달 열림, 일시적인 폼 값, 한 페이지 생명주기 안에서만 필요한 값.

- 스토어 설계: 여러 슬라이스 파일을 만들기 보다 프로젝트 규모에 맞게 하나의 store로 관리하여 store 규모 최소화 / persist 미들웨어로 최소 키만 영속화(예: user.token), 민감정보는 세션 스토리지 우선.

> 로딩/스켈레톤 UI로 체감 성능 개선

- Skeleton UI: 카드·차트·리스트 섹션별 스켈레톤 컴포넌트 분리(<VideoCard.Skeleton/>, <Chart.Skeleton/>)로 레이아웃 점프 방지.

- 섹션별 지연 렌더링: 우선순위 높은 블록(요약 KPI, 상단 리스트)부터 보여주고, 하위 섹션은 스켈레톤 → 본문 치환.

> 컴포넌트 재사용성

> 점수 모델 설계

: 점수는 여러 신호를 합산하는 방식인데, 너무 치우치지 않게 각 항목마다 최대 점수를 제한.

- 조회수가 빠르게 오르는 영상은 확산 속도 점수

- 영상 길이에 비해 얼마나 오래 보는지 추정해서 유지율 점수

    - 3분 이하는 0.6, 10분은 0.5, 20분은 0.4 이런 식으로 가중치를 줬습니다. 실제 유지율 데이터를 못 받으니, 길이를 활용한 대체 로직입니다.

- 좋아요·댓글 같은 참여율 점수

- 구독자 수 대비 조회수로 구독자 효율 점수

- 제목에 키워드 포함 시 검색 적합성 점수

- 업로드 시간이 저녁 피크 타임이면 시간 보너스 점수

    - 사람들이 주로 많이 보는 시간대, 저녁 6시~9시에 올리면 약간의 가점

위 점수를 합쳐서 점수를 계산.

> API 파이프라인 구조

- 검색 API로 키워드에 맞는 영상 ID

- 영상 상세 API로 조회수, 좋아요, 댓글, 길이 같은 데이터


# 주요 기능
-유튜브 영상 검색 및 조회수, 좋아요, 댓글 수 조회 (키워드 및 제목으로 검색)
-조회수 대비 구독자 수, 업로드일 기준 조회 속도, 시청 지속율, 참여율(댓글, 좋아요) 등을 분석하여 성과도 점수화
-성과도 평가
-자동완성 기능 (검색어 추천)
-검색 키워드 기반 검색 및 영상 제목 검색 지원


# 어려웠던 점과 해결 방법

> API에서 제공하지 않는 데이터들

: 유튜브 알고리즘에 중요한 지표인 평균 시청 유지율, 노출 클릭율은 API에서 제공하지 않습니다. 그래서 대체할 수 있는 지표를 모아 직접 성과 점수 로직을 만들었습니다. 이걸 통해 어떤 영상이 어느 정도의 성과를 내고 있는지에 따라 퍼질 가능성이 높은지 빠르게 볼 수 있게 했습니다.

> API 할당량

: 유튜브 API의 할당량에 제한이 있어 사이트 안에 포인트 제도를 넣었습니다. 사용자가 검색할 때마다 포인트가 차감되도록 해서, API 호출 빈도를 자연스럽게 줄였습니다. 이렇게 하면 실제 운영 상황에서도 트래픽이 몰릴 때 안정적으로 제어할 수 있습니다. 또한, 서버에 캐시를 두고 같은 요청은 일정 시간 동안 다시 호출하지 않게 방향 수립 중입니다.


# 느낀 점/한계점

: 이번 프로젝트를 진행하면서 단순히 데이터를 받아와서 패칭하는 수준이 아니라, 데이터를 어떻게 가공하고 시각적으로 표현할지에 대해 깊이 고민할 수 있었습니다. 사용자 페르소나를 설정하고 그에 맞는 요구사항을 반영하면서 기획 단계에서 시간이 더 들었지만, 그 과정에서 기능과 UI가 확장되고, AI를 활용한 분석 기능까지 구현하게 되면서 프로젝트의 깊이가 더해졌습니다. 특히 AI 응답을 단순히 화면에 출력하는 것이 아니라 가공 후 별도로 패칭하는 과정을 경험하며 데이터 후처리와 구조적 설계의 중요성을 체감했습니다.

UX 개선을 위해 Skeleton UI를 도입하여 로딩 시 레이아웃이 불안정하게 보이는 문제를 줄였고, AI 응답을 기다리는 과정에서는 가짜 Progress UI를 적용해 단계적으로 진행률을 표시하면서 사용자가 지루하게 느끼지 않도록 했습니다. 이 과정에서 사용자 경험을 고려한 인터페이스 설계가 얼마나 중요한지를 배울 수 있었습니다.

상태 관리에서는 Zustand를 사용하여 전역 상태와 지역 상태를 분리했습니다. 사용자 토큰, 영상 리스트, 로딩 상태 등은 전역 store에서 관리하고, 일시적인 값은 컴포넌트 단에서 처리하여 코드의 명확성과 유지보수성을 높였습니다. 다만 store 구조와 슬라이스 구성이 아직 완벽히 정리되지 않았고, 영속화 전략도 개선의 여지가 있어 리팩토링이 필요하다는 점을 느꼈습니다.

한계로는 유튜브 알고리즘에 대한 개인적인 추측을 기반으로 일부 기능을 설계했기에 실제 알고리즘과는 차이가 있을 수 있다는 점이 있습니다. 또한 프론트엔드 중심의 작업을 진행해왔기 때문에 백엔드와 DB 관련 경험이 부족하여, API 쿼터 관리나 데이터 캐싱, 서버 설계와 같은 부분에서는 아직 깊이가 부족하다고 생각합니다. 현재는 프로젝트가 진행 중이기 때문에 리팩토링과 성능 최적화 부분은 남아 있으며, 더 개선할 수 있는 여지가 많습니다.

# 앞으로 방향

> 클라이언트와 서버 모두에서 데이터 캐싱과 안정화 작업을 강화

: 프론트에서는 TanStack Query를 도입해 데이터 요청을 효율적으로 관리하려 합니다. 같은 요청을 여러 번 보내지 않고, 일정 시간 동안 캐시된 데이터를 재활용하면서 필요할 때만 새로 불러오도록 설정할 예정입니다. 검색 시에는 디바운스를 적용해 불필요한 호출을 줄이고, 페이지 전환 시 끊김 없이 자연스럽게 이어질 수 있도록 개선할 계획입니다.

> API 쿼터(요청 제한) 문제를 해결

: 백엔드에서는 API 쿼터(요청 제한) 문제를 해결하기 위해 캐시를 두어 같은 데이터를 반복적으로 호출하지 않게 하고, 요청이 몰릴 경우 중복된 요청을 한 번만 처리하도록 만들 예정입니다. 또한 1시간 단위로 데이터를 새로 갱신하는 식으로, 유튜브 API를 효율적으로 사용하는 구조를 고민 중입니다. 이렇게 하면 API 할당량을 아끼고 서비스 안정성도 높일 수 있을 거라 생각합니다.

> 인기있는, 핫 한 키워드 보여주기 (실시간 인기 검색어, 키워드)

: 실시간으로 변화하는 인기 검색어와 트렌드 키워드를 수집하여 홈 화면에 출력할 계획입니다. 이를 위해 Python 라이브러리나 웹 크롤링 방식을 도입하고, 향후에는 단순 출력을 넘어 추천 분석과 연계해 활용할 수 있도록 확장할 계획입니다.

> 다시 배포 및 CI/CD 재설정

: 초기에는 배포를 진행했으나, API 할당량 문제와 기능적 부족으로 현재는 배포를 중단한 상태입니다. 앞으로의 방향은 할당량 문제와 데이터적인 문제를 안정화하고 필요한 기능을 보완한 뒤, 백엔드는 EC2에 CD 파이프 라인을 열어 자동 배포하고, 프론트엔드 또한 Vecel 또는 Netlify를 통해 배포할 계획입니다.